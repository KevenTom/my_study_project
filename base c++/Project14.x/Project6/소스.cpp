//강의처음에 말씀드렸다시피 예외처리는 편리하긴하지만	위험성과 단점도 존재합니다. 알아봅시다.
#include<iostream>
#include<memory>//2 2해결 방법으로 나중에 배울 스마트포인터를 잠깐 사용해 봅시다.

using namespace std;

int main() {
	try {
		int* i = new int[10000000];
		unique_ptr<int> up_ii(i); //2 2스마트포인터중에 유니크포인터라는게 있습니다. 거기에 i를 넣어주면

		throw "error";

		//3 2delete[] i;//1 첫번째로 예외처리를 하다보면 메모리처리가 안되서 메모리누수가 발생할 수 있습니다. (위가 throw니까 아래에잇는 delete가 작동 안함)
		//3 2그러면 delete할 필요가 없어집니다. 나중에  실전에서 프로그래밍할때는 스마트포인터를 많이 사용할 거라고 함


		//4그리고 클래스 소멸자에 throw를 하면 안됩니다.
		//그리고 예외처리는 저번에 말한것처럼 많이 느립니다. 그래서 for문처럼 아주 빈번하게 작동하는곳에 예외처리를 하면 아주 많이 잡아먹겠죠
		//물론 한두번만 하는 간단한 곳에서는 전혀 문제가 되지 않습니다.
		//그리고 모든 오류처리를 다 예외처리를 받으려고 하지 마세요 정상적으로 작동해야하는건 정상적으로 작동하도록 if문으로 걸러네는게 좋습니다.
		//앞에서 사용한 cin은 예외처리보단 다시 cin을 할수 있도록 해주는게 더 좋겠죠
		//예외처리는 네트워크, 서버나 분산처리나 병렬처리, 하드관련 작업를 할때 즉, 논리적으로 대책을 하기 어려운 경우에 사용하는것이 좋습니다. 끝
	}
	catch (...) {
		cout << "catch" << endl;
	}
	return 0;
}