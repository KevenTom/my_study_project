//스마트포인터를 사용할때 의미론적 이동, 그러니까 move semantics를 항상 사용할수 있는것은 아닙니다.
//이번에는 무브시멘틱스를 사용할지 말지 혹은 사용할수 있는지 아니면 사용하면 안되는지를 판별할때 사용할수있는 오른쪽-값 참조(R-Value References)를
//지금까지 우리가 사용해온 왼쪽값참조와 비교를 하면서 살펴보겠습니다.
#include<iostream>

using namespace std;

int getResult() {
	return 100 * 100;
}



//4 가장큰 차이는 들어올때 파라미터가 l벨류 레퍼런스, r벨류 레퍼런스 라는 점이다. 
//이처럼 l,r 벨루 레퍼런스인것은 다르게 기능할 수 있도록 컴파일러가 오버로딩을 인정해주고 있다는것을 알 수 있습니다.

void dosomething(int& lref) {//7 반대로 L벨류 레퍼런스를 사용할 경우에는 lref에 들어오는것이 변수고 그 변수는 dosomething이 끝나도 사용할수 있어야 합니다.
	cout << "L-value ref" << endl;//그러니까 무브시멘틱스로 가져와버리면 바깥에서 dosomething함수를 호출한 후에 lref로 넘겨버린 변수를 다시 접근하려고 하면 문제가 발생하는겁니다.
	//즉 dosomething에서 L벨류에 대해서는 무브시멘틱스를 사용할 수 없습니다. 충돌이 일어납니다.
}
void dosomething(int&& rref) { //6 그렇기 때문에 dosomething 에서 R벨류 레퍼런스는 받아온 경우에는 이 안에서 rref에 담아있는 데이터를 무브해서 가져와도 된다는 겁니다. 
	cout << "R-value ref" << endl;//한마디로 rref는 어차피 다른곳에서 쓸수 없기 때문에 무브시멘틱스를 사용할 수 있는겁니다.
}

int main() {
	int x = 5; //1 이걸 보면 왼쪽에 있는 x가 L벨류, 오른쪽에 5가 R벨류 라는것을 알고 계실겁니다. 여기서 가장 중요한 차이는 
	//x는 어떤메모리 공간을 가지고 있다는 것이고 5는 문장이 끝나면 사라질 운명이라는 거죠, 그러니까 사라지기전에 x에 복사해서 계속 사용하겠다는 의미입니다.
	int y = getResult(); //2 여기는 5 대신에 함수에서 리턴하는 값인 R벨류를 L벨루인 y에 복사해서 넣어주고 있는거죠.
	const int cx = 6;
	const int cy = getResult(); // 상수는 말 그대로 복사하고 바꾸지못하게 하는 거죠


	//3 L벨류 레퍼런스를 다시 복습해봅시다.
	//주석처리된 코드는 컴파일이 안되는 코드입니다.
	//왼쪽값을 참조할수 있는 레퍼런스를 만드려면 '&' 이걸 붙였죠

	int& lr1 = x;		//Modifialbe l-values	이러면 lr1는 x와 같은 주소를 갖게 되죠
	//int& lr2 = cx;	Non-modifialbe l-values L벨류 레퍼런스가 컨스트가 아니면 컨스트를 넣을 수 없죠
	//int& lr3 = 5;		R-values				이처럼 그냥 숫자 5도 넣을 수 없습니다. 이게 중요한데 이유가 무엇이나면
	//L벨류 레퍼런스는 자기가 참조하고 있는 변수가 메모리를 가지고 있다고 전재하고 다른 이름인것처럼 작동하는것이기 때문에 애초에 메모리가 없는건 넣을수 없죠
	//그러니까 L벨류레퍼런스니까 L벨류만 가질 수 있고 R벨류 대해서는 레퍼런스를 가질수 없죠
	//사실은 지금까지 사용한 레퍼런스라는 단어는 전부 "L벨류 레퍼런스"를 지칭하는 단어였습니다.

	const int& lr4 = x;		//const레퍼런스니까 넣을 수 있고
	const int& lr5 = cx;	//마찬가지로 const레퍼런스니까 넣을 수 있고
	const int& lr6 = 5;		//그리고 R벨류도 넣을수 있습니다. 
	//R벨류를 넣을수 있는 이유는 어차피 메모리주소와 상관없이 이후에 수정하지 않을꺼니까 기호상수(symbolic constant)로만 사용할꺼니까 특별히 넣을 수 있는 겁니다.

	//R-value references
	//R벨류 레퍼런스는 L벨류 레퍼런스랑 다릅니다.
	//일단 R벨류 레퍼런스는 &가 두개입니다.
	//특징은 R벨류만 받을 수 있습니다. L벨류랑 반대죠
	//L벨류 레퍼런스는 R벨류는 못넣고 L벨류 레퍼런스에 대한 것만 받을 수 있었죠

	//int&& rr1 = x;	//Modifialbe l-values
	//int&& rr2 = cx;	//Non-modifialbe l-values
	int&& rr3 = 5;		//R - values	여기서는 반대로 R벨류래퍼런스에 대해서만 가질 수 있습니다.
	//이게 어떤의미가 갖냐면, 이 5는 사라질 운명이지만 얘를 보관할수 있게 해준다는 거죠
	int&& rrr = getResult(); //이것도 마찬가지로 getResult에서 리턴해주는 값도 R벨류니까 대입해줄수 있습니다.
	//이게 왜 필요한가 생각하실수 있습니다. 
	//이해하기 위해 앞에배운 move semantics와 이것이 컨트스럭터와 어사이먼트에서 어떻게 작동할때 그때 L벨류와 R벨류 사용하는것이 어떻게 구분이 되어있는지 보면 알수 있는데
	//간단하게 얘기하면 R벨류 레퍼런스는 곧 사라지는 애들만 담을수 있는 겁니다. 
	//그래서 R벨류 레퍼런스로 가리켜 지는 애들은 무브를 해서 따른곳으로 옮겨 버려도 어차피 곧 살아질 녀석이기 때문에 아무도 찾지 않게 되는 거죠
	//반대로 위의 변수 x 같은 경우에는 어디서든지 사용할 수 있죠, 그래서 x의 내용물을 딴곳에 옮겨버리면 x를 통해서 다시 접근할수 없으니까 충돌이 생기는 겁니다. (아마 전 강의에서 delete 두번하면 런타임 에러뜨는것을 애기하는거 같음)

	//const int&& ref4 = x; 마찬가지로 x는 Modifialbe l-values니까 접속할수 없고
	//const int&& ref5 = cx; 마찬가지로 Non-modifialbe l-values니까 안되고
	const int&& ref6 = 5; //R-value는 담을 수 있죠

	//여기서 해깔릴수 있는 요인은
	int&& rrrr = 5; //R벨류는 메모리에 잠깐 존재했다가 사라질 운명인데 R벨류 레퍼런스에 담아버리잖아요
	cout << rrrr << endl;
	rrrr = 10;
	cout << rrrr << endl;
	//어 근데 5는 사라질 운명인데 출력도 하고 값도 바꿀수 있는데? 말이 돼? 할수 있습니다.
	//그래서 이걸 어떻게 생각하면 되나면 "rrrr는 숫자 5 R-value에 나 아니면 아무도 접근할수 없어, 나만 사용하고 나만 바꿀수 있어"
	//이 얘기는 5가 만약 클래스의 오브젝트라면 걔가 가지고 있는 데이터를 rrrr로 이전을 해버려도 문제가 없다는 거고 이전하고 사용할 수 있겠다 라는 의미가 되는거죠
	//그러니까 클래스사용에서 무브시멘틱스를 사용하는 것은 이 R벨류레퍼런스와 아주 깊은 관계가 있다는 건데 구체적으로는 다음강의에서 설명해드리겠습니다.

	//이해하기 쉽게 사용하는 예제는 이겁니다.
	//함수 오버로딩을 하는데

	dosomething(x); //5 여기에는 l벨류 x를 넣으니까 오버로딩중 l벨류 레퍼런스를 파라미터를 갖는 dosomething이 호출이 됩니다.
	//dosomething(cx); //cx는 컨스트니까 컨스트가 아닌 레퍼런스는 받을수 없습니다.
	dosomething(5);//이건 R벨류니까 오버로딩중 R벨류 레퍼런스를 파라미터를 갖는 dosomething이 호출이 됩니다.
	dosomething(getResult()); //마찬가지로 R벨류니까 ㅇㅇ

	//8 마지막으로 실행하면 어떤 dosomething이 호출되는지 확인할 수 있습니다. 끝


	return 0;
}