//멀티쓰레딩은 여러개의 쓰레드들이 하나의 메모리의 공간을 함께 사용하기 때문에 다른 병렬처리기법에 비해 구현하기가 훨씬 편리합니다.
//그러나 같은 메모리공간을 공유할수 있다는 장점은 어떠한 경우에는 문제점이 발생할수도 있습니다.
//이러한 경우를 race condition(경쟁 상태)이라 부릅니다.
//이번에는 레이스 컨디션과 해결하기 위한 std::atomic, std::scoped_lock 을 알아봅시다.
#include<iostream>
#include<thread>
#include<atomic>
#include<mutex> //상호 배제라는 뜻인데 간단하게 여러 쓰레드 들이 동시에 어떠한 코드에 접근하는 것을 배제한다고 생각하시면 됩니다.

using namespace std;

mutex mtx;

int main() {
	//6 3int shared_memory = 0;
	//1 공유메모리가 정수 하나라고 가정해서 간단한 예제를 만들어보겠습니다.
	//이름이 shared_memory인 이유는 그냥 여러개의 쓰레드들이 이 변수에 동시에 접근할꺼기 때문입니다.

	atomic<int> shared_memory = 0; //6 3사용법은 간단합니다.

	if (true) {
		auto count_func = [&]() {
			for (int i = 0; i < 1000; ++i) {
				this_thread::sleep_for(chrono::microseconds(1)); //this_thread::sleep_for는 잠시 스레드를 sleep 해줍니다.
				//2 sleep_for가 있는 이유는 여러개의 쓰레드에게 일을 시켜도 너무 빨리 해결할때가 있어서 문제가 없는것처럼 보일때가 있기 때문입니다.
				//즉, sleep_for를 뺏다고 해서 문제가 없는것이 아닌, 안보이는 겁니다.
				//병럴프로그래밍의 어려운점 중 하나가 문제를 끄집어내는게 어려울때가 많습니다.

				//mtx.lock();
				//lock_guard<mutex> lock(mtx);
				scoped_lock lock(mtx);
				++shared_memory;
				//mtx.unlock();
			}
		};

		thread t1 = thread(count_func); //3 실행하면 shared_memory에 1000개 더하고
		thread t2 = thread(count_func); //여기에서 1000개 더하니까 총 2000이 되겠죠

		t1.join();
		t2.join();

		cout << "after : " << shared_memory << endl;
		//4 shared_memory를 보면 2000보다 적게 나온다는것을 알 수 있습니다.
		//원인이 뭘까요? 이는 cpu가 연산을 어떻게 처리하는지 알아야 합니다. 궁금하면 https://modoocode.com/270#page-heading-2
		//간단하게 얘기하면 쓰레드1에서 메모리의 값을 더해주기 위해서는 cpu로 쉐어드메모리의 값을 읽어오고 cpu에서 1을 더한 다음에 쉐어드메모리에 더한 값을 덮어씌웁니다. 총 3단계죠
		//여기서 문제는 쓰레드1에서 메모리를 읽어드린 사이에 쓰레드2가 메모리의 값을 바꿔버린겁니다.
		//즉, shared_memry를 한번에 한 쓰레드에서만 작업한다면 해결할수 있겠죠?
		
		//5첫번째로 atomic을 사용합니다.
		//atoomic은 간단하게 3단계를 한방에 해치우도록 묶어버린 변수라고 생각하시면 됩니다.
		//6 3아토믹으로 바꾼 후에 실행하면 정상적으로 작동하는것을 확인할 수 있습니다.
		//단, 단점은 아토믹이 기본 int보다는 조금 느립니다. 그러니까 아토믹을 여러곳에 많이 사용하는것보단 필요한부분에만 사용하셔야 합니다.

		//7 또는 뮤텍스의 락을 이용하여 해결하는 방법도 있습니다.
		//뮤텍스를 사용한 부분에서는 한 쓰레드에서만 사용권한을 갖게 됩니다.
		//unlock으로 풀면 다시 다른 쓰레드에서 lock을 걸고 다시 풀고 다시 걸고.... 반복하는 겁니다.
		//물론 언락을 까먹거나 여러가지 이유로 언락을 스킵될수도 있습니다.
		//언락이 안되면 다른 모든 쓰레드를 기다리게 됩니다. 이런 상황을 데드락(deadlock)이라 부릅니다. 데드락이 궁금하면 링크 ㄱ

		//8 이럴때 lock_guard를 사용하실 수 있습니다.
		//lock이라는 변수가 스코프 안에 선언이 되면 인위적으로 풀어줄 필요가 없습니다. 유니크포인터와 비슷하죠, 편리합니다
		//대부분의 경우에도 락가드로 사용하는것을 권장한다고 합니다.

		//9 c++17에서는 업그레이드된 scoped_lock이 있습니다. 요즘은 이걸 권장한다고 함
		//이처럼 멀티쓰레딩을 사용하실때는 레이스 컨디션을 주의하셔야 합니다.
		//참고로 스코프락을 사용한다고 해서 데드락이 완전방지되는것은 아닙니다. 끝
	}
	return 0;
}
