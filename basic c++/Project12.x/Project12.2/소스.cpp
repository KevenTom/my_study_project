//앞강의에서 다형성이 왜 필요한지 좋은지 위주로 설명해 드렸습니다. 다형성을 구현할때는 버츄얼 키워드를 사용했다는걸 알았습니다.
//버츄얼을 붙인 함수를 가상함수(virtual functions)라고 부르는데 이 가상함수의 문법적인 측면으로 알아봅시다.
#include <iostream>

using namespace std;

class A
{
public:
	//4 3void print() { cout << "A" << endl; }
	virtual void print() { cout << "A" << endl; } //4 3이번에는 앞에 버츄얼 키워드를 붙여보자.
};

class B : public A
{
public:
	void print() { cout << "B" << endl; }
};

class C : public B
{
public:
	void print() { cout << "C" << endl; }
};

class D : public C
{
public:
	//8 2void print() { cout << "D" << endl; }
	int print() { cout << "D" << endl; return 0; } //8 2오버라이딩을 할때 리턴타입이 다르면 어떻게 될까? 오류발생: A::print하고 다르다고 얘기함
};
//1 사실 프로그래밍하면서 상속을 많이 받는경우는 많지 않습니다. 많아봐야 2번3번 입니다. 그냥 알아두라고

int main()
{
	A a;
	a.print();
	B b;
	b.print();
	C c;
	c.print();
	D d;
	d.print();
	cout << endl;

	//2 지금부터 해볼려는건 포인터만 바꿔보려고 한다.
	A& ref = b;
	ref.print(); //3 B를 넣었지만 레퍼런스가 A에 둔것만인 이유로 A인것처럼 작동한다. 앞강의해봐서 알겠지만 포인터도 똑같이 작동한다.
	//4 3버츄얼을 넣어주니까 이번에는 B로 작동한다.
	//5 B클래스로 만들어진 인스턴스를 A의 레퍼런스에 넣었는데 그 A안에 있는 print가 버츄얼일 경우에는 상속받은 클래스에서 오버라이딩된 함수가 있을 경우에는 그 함수를 사용합니다.
	A& ref2 = c;
	ref2.print(); //6 출력하면 c로 나온다. c가 A를 직접 상속받은것은 아니지만 b를 상속받아서 거쳐받았지만 마찬가지로 사용할 수 있다.
	B& ref3 = c;
	ref3.print(); //7 출력하면 c로 나온다. 가장 상위클래스에 있는게 버츄얼이 되어버리면 밑에 있는 것도	다 버츄얼이 있는것처럼 행동한다는 것을 알수 있다.
				//그래서 해깔리기때문에 버츄얼 밑의 함수에도 의미없지만 버츄얼을 넣어준다. 밑에있는 함수에는 버츄얼을 넣어주든 말든 상관없이 작동하지만
				//그럼으로써 아 상위클래스에 버츄얼이 있구나 라는걸을 인지할수 있게 해준다.
	//9 나중에 익숙해지면 버츄얼펑션을 자주 사용하게 되는데 주의할점이 있다. 우리가 앞에서 배운 스택형식으로 작동하는것이 아닌,
	//버츄얼 테이블을 찾아가지고 함수를 찾아가는 과정을 거친다. 당연히 느린다. 그래서 호출이 되게 자주하는 함수에다가 버츄얼을 사용하는것은 좋지 않다. 끝

	return 0;
}